# 扑克牌游戏服务端接口文档

## 概述

本文档描述了扑克牌游戏服务端提供的主要功能和网络通信数据包格式。服务端主要通过 `GameServer` 类实现，负责处理客户端连接、游戏逻辑和状态同步。

## 服务端功能

### 玩家管理

- **玩家加入处理**：接收并处理玩家加入请求，分配玩家ID
- **玩家断开处理**：处理玩家断开连接的情况，维护游戏状态
- **玩家列表管理**：维护当前连接的玩家列表，并广播给所有客户端

### 游戏控制

- **游戏开始**：当玩家数量达到要求时，开始游戏（洗牌、发牌、确定首位玩家）
- **游戏结束**：当有玩家达成胜利条件时，结束游戏并通知所有客户端
- **游戏规则设置**：支持设置不同的游戏规则（北方规则、南方规则）

### 游戏逻辑处理

- **出牌处理**：验证玩家出牌是否有效，并广播给其他玩家
- **过牌处理**：处理玩家过牌请求，并更新游戏状态
- **回合管理**：控制游戏回合，确定下一位出牌玩家
- **胜利条件检查**：检查是否有玩家达成胜利条件

### 状态同步

- **游戏状态广播**：向所有客户端广播当前游戏状态
- **玩家手牌同步**：向各玩家发送其手牌信息
- **最后出牌同步**：向所有玩家广播最后出的牌

## 网络数据包格式

服务端和客户端之间通过以下数据包进行通信：

### 1. PlayerAction（玩家动作）

```java
public class PlayerAction {
    private String playerId;           // 玩家ID
    private ActionType actionType;     // 动作类型
    private String playerName;         // 玩家名称（仅用于加入游戏）
    private List<NetworkCard> playedCards; // 出的牌（仅用于出牌动作）
    
    // 构造函数、getter和setter方法
}

public enum ActionType {
    JOIN,       // 加入游戏
    PLAY_CARD,  // 出牌
    PASS,       // 过牌
    READY,      // 准备
    LEAVE       // 离开
}
```

### 2. GameStart（游戏开始）

```java
public class GameStart {
    private List<NetworkPlayer> players; // 参与游戏的玩家列表
    private String gameRule;             // 游戏规则（"NORTH"或"SOUTH"）
    private String firstPlayerId;        // 首位出牌玩家ID
    
    // 构造函数、getter和setter方法
}
```

### 3. GameStateUpdate（游戏状态更新）

```java
public class GameStateUpdate {
    private String currentPlayerId;              // 当前回合玩家ID
    private Map<String, Integer> playerCardCount; // 每个玩家的手牌数量
    private List<NetworkCard> lastPlayedCards;    // 最后出的牌
    private String lastPlayerId;                 // 最后出牌的玩家ID
    private List<NetworkCard> yourCards;         // 当前玩家的手牌（仅发送给特定玩家）
    
    // 构造函数、getter和setter方法
}
```

### 4. GameEnd（游戏结束）

```java
public class GameEnd {
    private String winnerId;               // 获胜玩家ID
    private Map<String, Integer> scores;   // 各玩家得分
    
    // 构造函数、getter和setter方法
}
```

### 5. Heartbeat（心跳包）

```java
public class Heartbeat {
    private long timestamp; // 时间戳
    
    // 构造函数、getter和setter方法
}
```

## 通信流程

### 游戏开始前

1. 客户端连接到服务器
2. 客户端发送 `PlayerAction(JOIN)` 加入游戏
3. 服务端广播更新后的玩家列表
4. 当玩家数量达到要求时，服务端发送 `GameStart` 开始游戏

### 游戏进行中

1. 服务端发送 `GameStateUpdate` 给所有玩家，包含初始游戏状态
2. 当前回合玩家发送 `PlayerAction(PLAY_CARD)` 或 `PlayerAction(PASS)`
3. 服务端验证操作有效性，更新游戏状态
4. 服务端广播 `GameStateUpdate` 给所有玩家
5. 重复步骤2-4，直到游戏结束

### 游戏结束

1. 当有玩家手牌为空或达到其他结束条件时，服务端发送 `GameEnd` 给所有玩家
2. 客户端显示游戏结果

## 错误处理

服务端对以下错误情况进行处理：

1. **无效操作**：如玩家在非自己回合尝试出牌，或出牌不符合规则
2. **连接断开**：玩家连接断开时，保持游戏状态并等待重连
3. **超时处理**：玩家长时间不操作时的处理机制

## 注意事项

1. 所有网络通信使用KryoNet库，确保客户端和服务端使用相同的数据包格式
2. 服务端需要注册所有数据包类型，使用 `PacketRegister` 类
3. 为防止作弊，服务端应验证所有客户端操作的有效性
4. 服务端应定期发送心跳包，检测客户端连接状态 