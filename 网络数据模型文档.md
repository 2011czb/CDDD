# 扑克牌游戏网络数据模型文档

## 概述

本文档详细描述了扑克牌游戏中网络传输使用的数据模型。这些模型用于客户端和服务端之间的通信，确保游戏状态的正确同步。

## 核心数据模型

### NetworkPlayer（网络玩家模型）

网络传输中使用的玩家信息模型。

```java
public class NetworkPlayer {
    private String id;           // 玩家唯一标识
    private String name;         // 玩家名称
    private boolean isReady;     // 玩家是否准备好
    private int cardCount;       // 玩家手牌数量
    private boolean isOnline;    // 玩家是否在线
    
    // 构造函数
    public NetworkPlayer() {}
    
    public NetworkPlayer(String id, String name) {
        this.id = id;
        this.name = name;
        this.isReady = false;
        this.cardCount = 0;
        this.isOnline = true;
    }
    
    // getter和setter方法
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public boolean isReady() { return isReady; }
    public void setReady(boolean ready) { isReady = ready; }
    
    public int getCardCount() { return cardCount; }
    public void setCardCount(int cardCount) { this.cardCount = cardCount; }
    
    public boolean isOnline() { return isOnline; }
    public void setOnline(boolean online) { isOnline = online; }
}
```

### NetworkCard（网络卡牌模型）

网络传输中使用的卡牌信息模型。

```java
public class NetworkCard {
    private int suit;    // 花色（0-黑桃，1-红桃，2-梅花，3-方块）
    private int rank;    // 点数（0-3对应A-4，4-12对应5-K）
    
    // 构造函数
    public NetworkCard() {}
    
    public NetworkCard(int suit, int rank) {
        this.suit = suit;
        this.rank = rank;
    }
    
    // 从Card对象转换为NetworkCard对象
    public static NetworkCard fromCard(Card card) {
        return new NetworkCard(card.getSuit().ordinal(), card.getRank().ordinal());
    }
    
    // 从NetworkCard对象转换为Card对象
    public static Card toCard(NetworkCard networkCard) {
        return new Card(Suit.values()[networkCard.suit], Rank.values()[networkCard.rank]);
    }
    
    // 批量转换方法
    public static List<NetworkCard> fromCardList(List<Card> cards) {
        if (cards == null) return null;
        return cards.stream()
                .map(NetworkCard::fromCard)
                .collect(Collectors.toList());
    }
    
    public static List<Card> toCardList(List<NetworkCard> networkCards) {
        if (networkCards == null) return null;
        return networkCards.stream()
                .map(NetworkCard::toCard)
                .collect(Collectors.toList());
    }
    
    // getter和setter方法
    public int getSuit() { return suit; }
    public void setSuit(int suit) { this.suit = suit; }
    
    public int getRank() { return rank; }
    public void setRank(int rank) { this.rank = rank; }
}
```

## 网络通信数据包

### ActionType（动作类型枚举）

定义玩家可以执行的动作类型。

```java
public enum ActionType {
    JOIN,       // 加入游戏
    PLAY_CARD,  // 出牌
    PASS,       // 过牌
    READY,      // 准备
    LEAVE       // 离开
}
```

### PlayerAction（玩家动作）

玩家发送给服务器的动作请求。

```java
public class PlayerAction {
    private String playerId;           // 玩家ID
    private ActionType actionType;     // 动作类型
    private String playerName;         // 玩家名称（仅用于JOIN动作）
    private List<NetworkCard> playedCards; // 出的牌（仅用于PLAY_CARD动作）
    
    // 构造函数
    public PlayerAction() {}
    
    public PlayerAction(String playerId, ActionType actionType) {
        this.playerId = playerId;
        this.actionType = actionType;
    }
    
    // getter和setter方法
    public String getPlayerId() { return playerId; }
    public void setPlayerId(String playerId) { this.playerId = playerId; }
    
    public ActionType getActionType() { return actionType; }
    public void setActionType(ActionType actionType) { this.actionType = actionType; }
    
    public String getPlayerName() { return playerName; }
    public void setPlayerName(String playerName) { this.playerName = playerName; }
    
    public List<NetworkCard> getPlayedCards() { return playedCards; }
    public void setPlayedCards(List<NetworkCard> playedCards) { this.playedCards = playedCards; }
}
```

### GameStart（游戏开始）

服务器发送给客户端的游戏开始通知。

```java
public class GameStart {
    private List<NetworkPlayer> players; // 参与游戏的玩家列表
    private String gameRule;             // 游戏规则（"NORTH"或"SOUTH"）
    private String firstPlayerId;        // 首位出牌玩家ID
    private List<NetworkCard> yourCards; // 当前玩家的手牌
    
    // 构造函数
    public GameStart() {}
    
    // getter和setter方法
    public List<NetworkPlayer> getPlayers() { return players; }
    public void setPlayers(List<NetworkPlayer> players) { this.players = players; }
    
    public String getGameRule() { return gameRule; }
    public void setGameRule(String gameRule) { this.gameRule = gameRule; }
    
    public String getFirstPlayerId() { return firstPlayerId; }
    public void setFirstPlayerId(String firstPlayerId) { this.firstPlayerId = firstPlayerId; }
    
    public List<NetworkCard> getYourCards() { return yourCards; }
    public void setYourCards(List<NetworkCard> yourCards) { this.yourCards = yourCards; }
}
```

### GameStateUpdate（游戏状态更新）

服务器发送给客户端的游戏状态更新。

```java
public class GameStateUpdate {
    private String currentPlayerId;              // 当前回合玩家ID
    private Map<String, Integer> playerCardCount; // 每个玩家的手牌数量
    private List<NetworkCard> lastPlayedCards;    // 最后出的牌
    private String lastPlayerId;                 // 最后出牌的玩家ID
    private List<NetworkCard> yourCards;         // 当前玩家的手牌（仅发送给特定玩家）
    
    // 构造函数
    public GameStateUpdate() {
        this.playerCardCount = new HashMap<>();
    }
    
    // getter和setter方法
    public String getCurrentPlayerId() { return currentPlayerId; }
    public void setCurrentPlayerId(String currentPlayerId) { this.currentPlayerId = currentPlayerId; }
    
    public Map<String, Integer> getPlayerCardCount() { return playerCardCount; }
    public void setPlayerCardCount(Map<String, Integer> playerCardCount) { this.playerCardCount = playerCardCount; }
    
    public List<NetworkCard> getLastPlayedCards() { return lastPlayedCards; }
    public void setLastPlayedCards(List<NetworkCard> lastPlayedCards) { this.lastPlayedCards = lastPlayedCards; }
    
    public String getLastPlayerId() { return lastPlayerId; }
    public void setLastPlayerId(String lastPlayerId) { this.lastPlayerId = lastPlayerId; }
    
    public List<NetworkCard> getYourCards() { return yourCards; }
    public void setYourCards(List<NetworkCard> yourCards) { this.yourCards = yourCards; }
}
```

### GameEnd（游戏结束）

服务器发送给客户端的游戏结束通知。

```java
public class GameEnd {
    private String winnerId;               // 获胜玩家ID
    private Map<String, Integer> scores;   // 各玩家得分
    
    // 构造函数
    public GameEnd() {
        this.scores = new HashMap<>();
    }
    
    // getter和setter方法
    public String getWinnerId() { return winnerId; }
    public void setWinnerId(String winnerId) { this.winnerId = winnerId; }
    
    public Map<String, Integer> getScores() { return scores; }
    public void setScores(Map<String, Integer> scores) { this.scores = scores; }
}
```

### Heartbeat（心跳包）

用于检测连接状态的心跳包。

```java
public class Heartbeat {
    private long timestamp; // 时间戳
    
    // 构造函数
    public Heartbeat() {
        this.timestamp = System.currentTimeMillis();
    }
    
    // getter和setter方法
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```

### ServerInfo（服务器信息）

服务器向客户端提供的服务器信息。

```java
public class ServerInfo {
    private String serverName;    // 服务器名称
    private int playerCount;      // 当前玩家数量
    private int maxPlayers;       // 最大玩家数量
    private boolean gameStarted;  // 游戏是否已开始
    private String gameRule;      // 游戏规则
    
    // 构造函数
    public ServerInfo() {}
    
    // getter和setter方法
    public String getServerName() { return serverName; }
    public void setServerName(String serverName) { this.serverName = serverName; }
    
    public int getPlayerCount() { return playerCount; }
    public void setPlayerCount(int playerCount) { this.playerCount = playerCount; }
    
    public int getMaxPlayers() { return maxPlayers; }
    public void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; }
    
    public boolean isGameStarted() { return gameStarted; }
    public void setGameStarted(boolean gameStarted) { this.gameStarted = gameStarted; }
    
    public String getGameRule() { return gameRule; }
    public void setGameRule(String gameRule) { this.gameRule = gameRule; }
}
```

## 数据包注册

所有网络数据包需要在客户端和服务端都进行注册，以便KryoNet库能够正确序列化和反序列化。

```java
public class PacketRegister {
    public static void registerPacketsFor(Client client) {
        registerPackets(client.getKryo());
    }
    
    public static void registerPacketsFor(Server server) {
        registerPackets(server.getKryo());
    }
    
    private static void registerPackets(Kryo kryo) {
        // 注册基本数据类型
        kryo.register(ArrayList.class);
        kryo.register(HashMap.class);
        
        // 注册枚举
        kryo.register(ActionType.class);
        
        // 注册数据模型
        kryo.register(NetworkPlayer.class);
        kryo.register(NetworkCard.class);
        
        // 注册数据包
        kryo.register(PlayerAction.class);
        kryo.register(GameStart.class);
        kryo.register(GameStateUpdate.class);
        kryo.register(GameEnd.class);
        kryo.register(Heartbeat.class);
        kryo.register(ServerInfo.class);
    }
}
```

## 使用示例

### 客户端发送出牌请求

```java
// 创建出牌动作
PlayerAction action = new PlayerAction(localPlayer.getId(), ActionType.PLAY_CARD);

// 转换要出的牌为网络卡牌模型
List<NetworkCard> networkCards = NetworkCard.fromCardList(cardsToPlay);
action.setPlayedCards(networkCards);

// 发送到服务器
client.sendTCP(action);
```

### 服务端处理出牌请求

```java
// 在接收到PlayerAction时
if (action.getActionType() == ActionType.PLAY_CARD) {
    String playerId = action.getPlayerId();
    List<Card> cards = NetworkCard.toCardList(action.getPlayedCards());
    
    // 验证出牌是否有效
    if (isValidPlay(playerId, cards)) {
        // 更新游戏状态
        updateGameState(playerId, cards);
        
        // 广播游戏状态更新
        broadcastGameStateUpdate();
    } else {
        // 发送错误消息给客户端
        sendErrorMessage(playerId, "无效的出牌");
    }
}
```

## 注意事项

1. 所有网络传输的数据模型类必须有一个无参构造函数，以便KryoNet可以实例化它们
2. 为了减少网络传输量，应只传输必要的数据
3. 敏感数据（如其他玩家的手牌）不应该发送给客户端
4. 所有从客户端接收的数据都应该在服务端进行验证，防止作弊
5. 客户端和服务端的数据模型版本必须保持一致 